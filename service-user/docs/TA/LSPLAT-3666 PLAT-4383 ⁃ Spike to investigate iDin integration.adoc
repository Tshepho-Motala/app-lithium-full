= LSPLAT-3666 - PLAT-4383 ⁃ Spike to investigate iDin integration
Irwin Herridge <irwin.herridge@wonderlabz.com>
1.0, February 28, 2022:: TA - LSPLAT-3666 - PLAT-4383 ⁃ Spike to investigate iDin integration
:toc: left
:toclevels: 4
:toc-title: LSPLAT-3666 PLAT-4383
:icons: font
:url-quickref: https://docs.asciidoctor.org/asciidoc/latest/syntax-quick-reference/

== Information
=== Tickets
* https://jira.livescore.com/browse/PLAT-4383
* https://playsafe.atlassian.net/browse/LSPLAT-3666

=== Dependencies
* N/A

=== MR
* https://gitlab.com/playsafe/lithium/app-lithium-full/-/merge_requests/4404
* This MR contains the branch that should be used to complete this task!

== Description (From Ticket)
=== Business

We want to look at how we can integrate with iDin from Sphonic, with minimal changes to the existing registration and document uploadd processes.

On reg, user will be able to complete reg manually or via iDin - which will allow the platform to retrieve all personal details for the user, to allow them to complete reg quicker and verify their details as per regulations.

==== From Sphonic

We have been looking at the integration further and would like to propose this: user starts the application on Livescore app - Livescore call Sphonic workflow 1 with unique user ID and the URL they want the user sent to once they’ve completed IdIn * workflow 1 kicks off the Idin process, calls BlueM and returns the URL that Livescore need to redirect the user to for giving consent and logging into their bank etc.

. User does the IdIn bit and gets sent to the livescore-specified URL when the process is complete (will need to be some kind of holding “Please wait while we retrieve the details from your bank”) screen. The specifics of the holding screen is at the discression of the product owners and is beyond the scope of the core backend process.
. When the user gets the holding page, Livescore calls Sphonic workflow 2
. Workflow 2 calls Bluem and retrieves the bank name/address/dob details and then returns the response back to Livescore

=== History

iDin has been fast tracked as a solution to enhance our conversion of P2P in LSBNL. The market has some of the strictest verification processes in the industry and iDin allows users to log into their bank’s system to help verify their identity which greatly improves their experience compared with completing registration manually. iDin is widely adopted in NL and supported by all major banks.

We are investigating two spikes to get us the iDin MVP ASAP:

. Spike 1: Native iDin solution (via Sphonic only): we integrate iDin into our existing registration flow and offer the customer the opportunity to sign up manually or via iDin. We do not have the capability to report on the full P2P journey end to end currently to identify drop off points.  This solution is commercially cheaper although we expect there to be a reduced conversion in P2Ps because the flow will be an MVP and not tested like option 2. (*IN SCOPE*: https://jira.livescore.com/browse/PLAT-4383)

. Spike 2: iDin via Checkin.com: we integrate an Iframe from Checkin.com which we hope can act as a plug and play and allow us a greater speed to market. The reg flow can be configured to our needs and has built in A/B testing functionality and reporting, which is important to test our hypotheses going into a new market. This could allow us to find the optimised journey for our product while we build our native solution in the background. There will be some redundant work used integrating this before building our own solution. (*OUT OF SCOPE*: https://jira.livescore.com/browse/PLAT-5621)

Top level estimate for both options are similar with forecasts for the end of March.

**The front runner is the native iDin (via Sphonic only) solution because development time forecasts are similar for back end work and the costs associated with the Checkin.com option are more expensive than initially expected.**

Early investigations into post MVP scope to include the ability for the user to re-join their iDin registration journey and not lose their details already entered on the form.

===== Links:

* https://developer.signicat.com/enterprise/identity-methods/idin.html
* https://www.idin.nl/en/about-idin/

== Architecture

=== Overview

This architecture is only investigating "Spike 1" which is looking at using the Native iDin solution (via Sphonic only)

As a result, the following high-level interaction diagram has been produced showing the architectural significant components / interactions between LivescoreApp, Lithium and Sphonic whereby GW is implied between the LivescoreApp and Lithium interactions.

.iDin Integration via Sphonic Overview
[plantuml]
----
@startuml
'https://plantuml.com/sequence-diagram

actor player
boundary "Livescore App / GW" as lsa
participant "svc-user" as su
participant "svc-user-pr-sphonic-idin" as supsi
participant "svc-access" as sa
boundary "iDin Screens" as idin
participant Sphonic as sphonic

autonumber

== STEP#1: iDin START ==

player-->lsa: Register using iDin
activate lsa
    alt Resume session
        note right of lsa
            * On LivescoreApp the applicantHash may be stored in session which may then be used to re-join at STEP#3 by using the returnUrl and applicantHash that was
              generated on Lithium as part of the iDINStart Workflow
        end note
        lsa->lsa: retrieve applicantHash from session
        alt applicantHash found in session
            lsa->lsa: resume STEP#3
        end
    end
    lsa->su: {{gateway}}/service-user/players/{domainName}/register/incomplete/v1?method=idin
    note left of su
        PlayerBasic request body {
            "stage": "1",
            "additionalData": {
                "iDinReturnUrl": "http://returnURL"
            }
        }
    end note
    alt method=idin, stage=1
        activate su
            su->su: resolve idin registration provider (service-user-provider-sphonic-idin)
            su->su: buildUserDetailsRequest
            su->supsi: {{gateway}}/service-user-provider-sphonic-idin/system/external-register
            note left of supsi
                ExternalUserDetailsRequest {
                    "stage": 1,
                    "domainName": "livescore_nl",
                    "playerBasic": {
                        "additionalData": {
                            "iDinReturnUrl": "http://returnURL",
                            "playerIpAddress": "5.250.191.25"
                        }
                    }
                }
            end note
            activate supsi
                supsi->supsi: Generates unique applicantHash
                supsi->supsi: Creates a new idin_request
                note right of supsi
                    * ** requestId **: to be generated by Lithium
                        * requestId is used by Sphonic as a correlation id between multiple requests

                    * ** applicantHash **: will be generated by the Lithium and needs to be unique
                        * Each hash will be linked to an applicantId where the applicantId would simply be the id on idin_request table
                        * The hash should be generated using the playerIpAddress and timestamp

                    * ** returnUrl **:
                        * Later in the flow as part of the iDin redirect back to returnUrl -> Livescore App would make use of the applicantHash
                           to retrieve the applicant data and would populate the registration screens with the applicant data as needed.

                    ** An incomplete user will be created and associated to the applicantHash and will also store the stage, createdDate and lastModifiedDate which may be used to see where players drops off in the process. **
                end note
                supsi -> sphonic: get access token
                activate sphonic
                    sphonic -->> supsi: accessToken
                deactivate sphonic
                supsi->sphonic: iDinStart Worflow request(requestId, applicationId, returnUrl)
                note left of sphonic
                    IDINStart Request: {
                      "requestDetails": {
                        "requestId": "{{lithiumRequestId}}",
                        "requestDateTime": "2022-03-16T13:03:43"
                      },
                      "requestData": {
                        "Applicant_Reference": "{{idinRequest.id}}",
                        "Return_URL": "https://applicaton.livescore.net/holdingpage"
                      }
                    }
                end note
                activate sphonic
                    note left of sphonic
                        IDINStart Response: {
                           "sphonicResponse": {
                               "data": {
                                   "responseDateTime": "2021-11-09T17:32:28Z",
                                   "livescoreRequestId": "{{lithiumRequestId}}",
                                   "livescoreAppliantId": "{{idinRequest.id}}",
                                   "sphonicTransactionId": "56c14f84-bf73-4355-88ab-9d6985ebbd22",
                                   "bluemTransactionId": "a117638133e7277",
                                   "identURL": "https://test.vmb.fyi/s/BZYGCA"
                               }
                           }
                       }
                    end note
                    sphonic-->supsi: iDinStart Worflow response(bluemTransactionId, verificationUrl=identURL)
                deactivate sphonic
                supsi->supsi: updates idin_request table with iDinStart response fields
                note right of supsi
                    * Adds bluemTransactionId and verificationUrl to idin_request table for later retrieval via the applicantHash that was used to create the idin_request record
                end note
                supsi->supsi: buildExternalUserDetailsResponse
                note left of supsi
                    ExternalUserDetailsResponse {
                        "stage": 1,
                        "domainName": "livescore_nl",
                        "outcome": "Success"
                        "playerBasic": {
                            "additionalData"": {
                                "iDinApplicantHash": "averyuniquehash",
                                "iDinVerificationUrl": "https://test.vmb.fyi/s/BZYGCA"
                            }
                        }
                    }
                end note
                supsi-->su: Response ExternalUserDetailsResponse
            deactivate supsi
            su->su: map userDetailsResponse.playerBasic to Incomplete register playerBasic request body
            su->su: creates new incomplete_user with iDinVerificationUrl and iDinApplicantHash stored as incomplete_user_label_value's
        end
        note left of su
            * For method=idin, we will be removing the incomplete_user.id from the Incomplete User response since the applicantHash would need
              to be used as a secure identifier when returning on stage 2 when continuing the iDin registration journey
        end note
        su-->lsa: Response Incomplete User
    deactivate su
    lsa->lsa: Adds applicantHash to session
    note right of lsa
        * iDin will be keeping state for up to 90 days after consent has been provided and therefore should the user have
          completed the iDin external screen flows (STEP#2) but have not completed the registration flow (STEP#3), then the LivescoreApp may resume
          at STEP#3 using the returnURL and applicantHash.
        * Should the iDin outcome be Expired or Cancelled, then the applicantHash needs to be removed from the LivescoreApp session and have the process re-started from STEP#1

        Outcomes from iDin:
        * Expired
          * Remove applicantHash from session on LivescoreApp and restart at STEP#1
        * Cancelled
          * Remove applicantHash from session on LivescoreApp and restart at STEP#1
        * Success
          * Need to re-join at STEP#3 by redirecting to returnURL using applicantHash that was stored in session
        * Failure
          * Remove applicantHash from session on LivescoreApp and restart at STEP#1
    end note

== STEP#2: Interacts with iDin / bank screens ==

lsa->>idin: Sends player to verificationUrl
activate idin
    note right of idin
        * Verification URL loads the iDin Screens for the user to interact with: the implementation of these screens are out of bounds to Lithium
            * On completion of the iDin screens, Livescore App would redirect to the returnUrl which is based on the redirect URL on STEP#3 which includes a
              uniquely identifier applicantHash to pull the players personal details into the registration screens
    end note
player-->idin: Interacts with iDin / bank screens
idin->>lsa: on iDin screen flow end, redirects to returnUrl
deactivate idin

==STEP#3: Redirects back to returnURL ==
lsa->lsa: Loads the returnURL
note right of lsa
    * The returnURL is essentially a magic link, since it may be used by the LivescoreApp to load the registration screen with some of the players personal details prefilled

    Due to the nature of this API being open to the world and would essentially allow a hacker to resume with the players personal details prefilled, an SHA key needs to be calculated by the LivescoreApp
    to secure the call to Lithium when retrieving sensitive information.
    * To calculate the SHA, we will be using payload = apiAuthorizationId + "|" + iDinApplicantHash + "|" + sharedSecret, then MDA5'ed with a payload
end note
    lsa->su: {{gateway}}/service-user/players/livescore_uk/register/incomplete/v1?method=idin&sha=calculatedusingpayloadandsharedsecret&apiAuthorizationId=ls-gw
    activate su
        note left of su
            Request body {
                 "stage": "2",
                 "additionalData": {
                     "iDinApplicantHash": "averyuniquehash"
                 }
             }
        end note
        alt method=idin, stage=2
            su->su: validate SHA calculated payload apiAuthorizationId|iDinApplicantHash|sharedSecret
            su->su: find incomplete_user by iDinApplicantHash
            su->supsi: {{gateway}}/service-user-provider-sphonic-idin/system/external-register
            note left of supsi
                ExternalUserDetailsRequest {
                    "stage": 2,
                    "domainName": "livescore_nl",
                    "playerBasic": {
                        "additionalData": {
                            "iDinApplicantHash": "averyuniquehash"
                        }
                    }
                }
            end note
            activate supsi
                supsi->supsi: find idin_request for unique applicantHash
                supsi -> sphonic: get access token
                activate sphonic
                    sphonic -->> supsi: accessToken
                deactivate sphonic
                supsi->sphonic: iDinRetrieve Worflow request(requestId, bluemTransactionId)
                activate sphonic
                    note left of sphonic
                        IDINRetrieve Request: {
                            "requestDetails": {
                              "requestId": "{{idinRequest.lithiumRequestId}}",
                              "requestDateTime": "2021-11-09T17:32:28Z"
                            },
                            "requestData": {
                              "bluemTransactionId": "{{idinRequest.bluemTransactionId}}"

                            }
                        }
                    end note
                    note right of sphonic
                        * If the check is successful the response will show that the outcome is “success” and will return the applicants name, address, dob, gender
                          and contact details.
                        * If the check is not successful it will return in the response an outcome "Failure"
                    end note
                    note left of sphonic
                        IDINRetrieve Response: {
                           "SphonicResponse": {
                               "data": {
                                   "traceData": {
                                       "responseDateTime": "2021-11-10T14:09:27.882Z",
                                       "livescoreRequestId": "{{idinRequest.lithiumRequestId}}",
                                       "livescoreApplicantId": "{{idinRequest.id}}",
                                       "sphonicTransactionId": "fce35022-3ce1-4208-a449-02b0e63f4593",
                                       "bluemTransactionId": "f7e57b272bf3cebb"
                                   },
                                   "outcome": {
                                       "transactionResult": "Success",
                                       "reason": "Bank data received",
                                       "authenticationAuthorityId": "RABONL2U",
                                       "authenticationAuthorityName": "Rabobank iDIN issuer simulatie",
                                       "idResponse": {
                                           "type": "BIN",
                                           "identifier": "FANTASYBANK1234567890"
                                       }
                                   },
                                   "nameData": {
                                       "initials": "VJ",
                                       "legalLastName": "Vries",
                                       "legalLastNamePrefix": "de",
                                       "preferredLastName": "Vries-Jansen",
                                       "legalFirstName": "",
                                       "preferredFirstName": ""
                                   },
                                   "addressData": {
                                       "houseNumber": "19",
                                       "houseNumberSuffix": "",
                                       "street": "Pascalstreet",
                                       "addressExtra": "",
                                       "city": "Aachen",
                                       "postalCode": "0000AA",
                                       "countryCode": "DE",
                                       "internationalAddressLine1": "",
                                       "internationalAddressLine2": "",
                                       "internationalAddressLine3": ""
                                   },
                                   "ageData": {
                                       "dateOfBirth": "1975-07-25"
                                   },
                                   "genderData": {
                                       "gender": "MALE"
                                   },
                                   "contactData": {
                                       "phoneNumber": "+31203051900",
                                       "email": "info@equensworldline.nl"
                                   }
                               }
                           }
                       }
                    end note
                    sphonic-->supsi: iDinRetrieve Worflow response(outcome, personalData)
                deactivate sphonic
                supsi->supsi: buildExternalUserDetailsResponse from iDinRetrieve response(outcome, applicantName, address, dob, gender, contactDetails)
                note right of supsi
                    * ExternalUserDetailsResponse.outcome = SphonicResponse.data.outcome.transactionResult
                    * All personal details needs to be mapped to the PlayerBasic
                end note
                note left of supsi
                    ExternalUserDetailsResponse {
                        "stage": 2,
                        "domainName": "livescore_nl",
                        "outcome": "{{SphonicResponse.data.outcome.transactionResult}}"
                        "playerBasic": {
                            ...mapped personal information...
                            "additionalData"": {
                                "iDinApplicantHash": "averyuniquehash"
                            }
                        }
                    }
                end note
                supsi-->su: Response ExternalUserDetailsResponse
            deactivate supsi
            su->su: update incomplete_user with personalData and store outcome as status=success with statusReason= on incomplete_user
            alt "SphonicResponse" does not contain required "addressData"
                su->su: update status to "SUCCESS"
                su->su: no address is created and linked to incomplete_user
            else
                su->su: update status to "SUCCESS"
                su->su: create address and link it to incomplete_user
            end
        end
        note left of su
            * For method=idin, we will be removing the incomplete_user.id from the Incomplete User response since the applicantHash would need
              to be used as a secure identifier when finally registering the user on Lithium using the register/v4 endpoint
        end note
        su-->lsa: Response Incomplete User
    deactivate su
    lsa->lsa: LivescoreApp loads registration screen with players personal Data retrieve

== STEP#4: continues with registration flow on Livescore App ==

player->lsa: continues with registration flow

lsa->sa: /service-access/external/authorization/livescore_nl/cruksAccessRule/check-authorization?locale=nl
activate sa
    sa-->lsa: Response ExternalValidationResponse
deactivate sa
note right of lsa: Should a valid CRUKS ID be returned on the ExternalValidationResponse, then the user would continue with the registration flow
lsa->su: /service-user/frontend/livescore_nl/register/v4?locale=nl
activate su
    ... pre registration flow...
    alt is incomplete user (playerBasic.additionalData.iDinApplicationHash)
        alt incomplete user found
            su->su: copy incomplete_user data to playerBasic
            alt incomplete user does not have an address associated
                su -> su: mark address_verified=false
            else address associated on incomplete_user
                su -> su: mark address_verified=true
            end
        else incomplete user not found
            su->lsa: Status463IncompleteUserRegistrationException
        else incomplete_user.status != "Success"
            su->lsa: Status463IncompleteUserRegistrationException
        end
    end
    ... post registration flow ...
    alt registered from an incomplete_user
        su->su: remove incomplete_user after success user registration (cleanup)
    end
    su-->lsa: Response User
deactivate su

deactivate lsa

@enduml
----

=== Technical

. Create a new service-user-provider-sphonic-idin module under service-user
    * Include *library-access-provider-sphonic* in your pom
[source, xml]
<dependency>
    <groupId>lithium</groupId>
    <artifactId>library-access-provider-sphonic</artifactId>
</dependency>

    * Include the sphonic libraries into your new user provider module (see sphonic access providers)
[source, java]
@ComponentScan(basePackages = "lithium.service.access.provider.sphonic")
@EntityScan(
    value = {
        "lithium.service.access.provider.sphonic.data.entities"
    }
)
@EnableJpaRepositories(
    value = {
        "lithium.service.access.provider.sphonic.data.repositories",
        "lithium.service.user.provider.sphonic.idin.storage.repositories"
    }
)


. Create a new `ProviderType.REGISTER` and have your new service-user-provider-sphonic-idin module register its provider properties against this new provider type.
* The register provider will provide a single wrapper endpoint that will be used for stage 1 and stage 2 processing.
* Add a new `Register` tab to  LBO -> Domain -> Providers screen that will be used to configure the register provider settings
* Create a new ExternalRegisterRequest and ExternalRegisterResponse objects that will be used as a generic request body and response to and from the user register providers
** Request
[source, java]
public class ExternalUserDetailsRequest {
    private Long stage;
    private String domainName;
    private PlayerBasic playerBasic;
}
** Response
[source, java]
public class ExternalUserDetailsResponse {
    private Long stage;
    private String domainName;
    private String outcome;
    private PlayerBasic playerBasic;
}
* Implement a new `{{gateway}}/service-user-provider-sphonic-idin/system/external-register` endpoint that may be used by all service-user-provider-* that had registered themselves as a `ProviderType.REGISTER` to provide a generic external registration provider service that may support multiple steps in a registration process.
** See overview sequence diagram and sphonic documentation for more information on implementing these rest API's
** Note that you would also need to authenticate on Sphonic before being able to call any of their workflow endpoints. Refer to sphonic access provider implementations `SphonicAuthenticationService#getAccessToken`

. Implement two stages as described in the overview plantuml diagram on STEP#1 and STEP#3
* Note when no method is provided on `{{gateway}}/service-user/players/{domainName}/register/incomplete/v1`, then the normal incomplete registration flow should be executed.
** For now we will only support an idin method, and for any other method provided a `Status 404 Method Not Found Exception` needs to be returned to the consumer.
** When method=idin we would need to resolve the providerURL by getting all the providers that was registered on the particular domain where the `ProviderType=REGISTER` and the providerURL contains idin.

. Create a new DB Schema for called `lithium_user_pr_sphonic_idin
* You will need the basic few tables created as we did for cruks and iban access providers in your initial V1 sql script
** authentication
[source,sql]
CREATE TABLE `authentication` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `access_token` longtext NOT NULL,
    `expiration_date` datetime NOT NULL,
    `version` int(11) NOT NULL,
    `domain_id` bigint(20) DEFAULT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `idx_domain` (`domain_id`),
    CONSTRAINT `FKh8beg2hbv9fog77fersm8ar15` FOREIGN KEY (`domain_id`) REFERENCES `domain` (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
** domain
[source,sql]
    CREATE TABLE `domain` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `name` varchar(255) DEFAULT NULL,
    `version` int(11) NOT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `idx_domain_name` (`name`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
** user (the applicantHash should be generated using the players IP address and timestamp)
[source,sql]
    CREATE TABLE `user` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `applicant_hash` varchar(255) DEFAULT NULL,
    `version` int(11) NOT NULL,
    `domain_id` bigint(20) NOT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `idx_guid` (`applicant_hash`),
    KEY `FKk1hggftp46a7obgff5evl2g4s` (`domain_id`),
    CONSTRAINT `FKk1hggftp46a7obgff5evl2g4s` FOREIGN KEY (`domain_id`) REFERENCES `domain` (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
** idin_request
[source,sql]
    CREATE TABLE `idin_request` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT,
    `lithium_request_id` varchar(255) DEFAULT NULL,
    `sphonic_transaction_id` varchar(255) DEFAULT NULL,
    `bluem_transaction_id` varchar(255) DEFAULT NULL,
    `idin_applicant_hash`    varchar(255) NOT NULL,
    `return_url` varchar(255) DEFAULT NULL,
    `verification_url` varchar(255) DEFAULT NULL,
    `player_ip_address` varchar(255) DEFAULT NULL,
    `version` int(11) NOT NULL,
    `domain_id` bigint(20) NOT NULL,
    `user_id` bigint(20) NOT NULL,
    `created_date` bigint(20) NOT NULL,
    `last_modified_date`  bigint(20) UNSIGNED,
    PRIMARY KEY (`id`),
    UNIQUE KEY `idx_idin_request` (`domain_id`, `user_id`),
    KEY `FKk1hsftph6a7bydfffge32g46` (`domain_id`),
    KEY `FKk1hsffdsowp7bydffe2ge32g46` (`user_id`),
    CONSTRAINT `FKk1hsftph6a7bydfffge32g46` FOREIGN KEY (`domain_id`) REFERENCES `domain` (`id`),
    CONSTRAINT `FKk1hsffdsowp7bydffe2ge32g46` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

. Change the PlayerBasic.stage and IncompleteUser to an Integer instead of a String
* Since there are no incomplete_user currently on prod, you may ask in your release instructions to remove all incomplete users form the incomplete_user table for dev, qa and staging only, before rolling service-user (This would allow a speedy data type alter on incomplete_user.stage)

. Remove the id from the IncompleteUser response for idin incomplete user registration flow
* The applicantHash would need to be used as a idin incomplete user identifier and will be used as identifier on the final registration step to pull the information from the incomplete user tables.

. LBO → Add Providers should not allow a user to configure more than one of the same provider type per domain/providerType
* Reason: When we are resolving a provider type for a domain, if more than one provider exist a list of providers are returned and this results in configuration issues where we are not able to call the provider

. LBO → Add Providers should only show provider URLs for providers relevant to the provider type the provider has been configured for.
* We should not be able to configure a provider on LBO on a provider type tab for which it was not build for.

. Calculating SHA on Stage 2 `{{gateway}}/service-user/players/{domainName}/register/incomplete/v1`
* First, we need to validate the `sha` against a `sharedSecret` that will be stored in our service-user application.yml file. Example: ExternalApiAuthenticationService#validate
** We will need a new `external-api-authorizations` key-value property that we may use to retrieve the `secret-key` by `id` and then have it MD5 encrypted by using the `apiAuthorizationId|iDinApplicantHash|sharedSecret` as the payload where external-api-authorizations.id equals the `apiAuthorizationId` from the `/register/incomplete/v1` request parameter

[source, yaml]
lithium:
      external-api-authorizations:
        - id: ls-gw
          secret-key: HFCWHFK7IUF23IGJKJ5GVIUTDF3O

* If PLAT-4685 has not yet been implemented, then you will need to move `lithium.service.limit.services.PublicApiAuthenticationService` into the library-service module under `lithium.services.ExternalApiAuthenticationService`
** You do not need to touch those impacted controllers mentioned in the ticket.
** LSPLAT-3052 PLAT-3784 - Support for GW error message migration to Lithium is also implementing this, but has not been deployed yet, see https://gitlab.com/playsafe/lithium/app-lithium-full/-/merge_requests/4493/diffs

=== Glossary

|===
|Field |Description

|applicantHash
|A unique identifier used to track an incomplete user being registered via an external registration provider.

The identifier is a hash key that gets generated on the first step of the incomplete registration flow and thereafter will be encrypted along with a shared secret in subsequent steps where personal information may be returned to complete the final registration steps.

Once the player completes the final registration step the applicantHash won't be usable anyore but may be used internally for reference back to Sphonic and iDin for reporting purposes.

|lithiumRequestId
|A UUID that gets generated on Lithium and will be sent as the requestID on the IDINStart and IDINRetrieve Sphonic endpoints

The same UUID will be generated on the IDINStart flow and retrieved from idin_request.lithium_request_id before calling the IDINRetrieve workflow and will therefore serve as a correlation id between the two workflow requests.

|verificationURL
|The verification URL (also called the identURL) loads the iDin Screens for the user to interact with: the implementation of these screens are out of bounds to Lithium

|returnURL
|The returnURL is passed to bluem via Sphonic and once the flow ends from the verificationURL, then the app will re-direct back to the returnURL from which the LivescoreApp will then continue in the multi-step registration flow.

|bluemTransactionId
|A unique identifier created on BlueM and is linked to the player information entered on the iDin screens; Lithium calls Sphonic with this on the IDINRetrieve workflow to return the players details when the player has provided consent to do so.

|sphonicTransactionId
|A unique identifier created on Sphonic and is linked to a request from Lithium and may be used to trace requests between Lithium and Sphonic.
|===

=== Provider Settings

==== Sphonic iDin Staging
|===
|Property |Value

|authenticationUrl
|https://user-mgnt-api-stg.sphoniclabs.net/api/v1/machines/login/universal-router-stg

|username
|api@livescore.com

|password
|It would not be a secret if I told you, check on LBO or consult with product owner...

|merchantId
|d03bd5dc-a450-4b23-a806-213bcf834224

|iDinUrl
|https://universal-router.stg.sphoniclabs.net

|iDinStartWorkflowName
|IDINWorkflow1

|iDinRetrieveWorkflowName
|IDINWorkflow2

|connectionRequestTimeout
|_configarable in seconds_

|connectionTimeout
|_configarable in seconds_

|socketTimeout
|_configarable in seconds_

|===

==== Sphonic iDin Prod
|===
|Property |Value

|authenticationUrl
|https://user-mgnt-api-stg.sphoniclabs.net/api/v1/machines/login/universal-router-stg

|username
|platformproduct@livescore.com

|password
|It would not be a secret if I told you, check on LBO or consult with product owner...

|merchantID
|56cb7bfc-7f61-409a-9a5a-3ecc91adfeca

|iDinUrl
|https://universal-router.sphonic.net

|iDinStartWorkflowName
|IDINStart

|iDinRetrieveWorkflowName
|IDINRetrieve

|connectionRequestTimeout
|_configarable in seconds_

|connectionTimeout
|_configarable in seconds_

|socketTimeout
|_configarable in seconds_

|===

* Building up the URL for the iDin workflows API calls
** iDinStart Workflow: `iDinUrl + "/" + merchantID + "/" + iDinStartWorkflowName`
** iDinRetrieve Workflow: `iDinUrl + "/" + merchantID + "/" + iDinRetrieveWorkflowName`

=== Out of Scope (Iteration 2)

. Should the incomplete_user not have successfully completed the idin reqestration flow (idin outcome != success), then a new Status463IncompleteUserRegistrationException needs to be thrown, indicating that the user has not completed their incomplete user flow.
