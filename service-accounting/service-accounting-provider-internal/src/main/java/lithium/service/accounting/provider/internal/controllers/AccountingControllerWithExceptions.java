package lithium.service.accounting.provider.internal.controllers;

import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import lithium.exceptions.ErrorCodeException;
import lithium.exceptions.Status415NegativeBalanceException;
import lithium.exceptions.Status500InternalServerErrorException;
import lithium.metrics.TimeThisMethod;
import lithium.service.Response;
import lithium.service.accounting.client.AccountingClientWithExceptions;
import lithium.service.accounting.exceptions.Status410AccountingAccountTypeNotFoundException;
import lithium.service.accounting.exceptions.Status411AccountingUserNotFoundException;
import lithium.service.accounting.exceptions.Status412AccountingDomainNotFoundException;
import lithium.service.accounting.exceptions.Status413AccountingCurrencyNotFoundException;
import lithium.service.accounting.exceptions.Status414AccountingTransactionDataValidationException;
import lithium.service.accounting.objects.AdjustmentRequest;
import lithium.service.accounting.objects.AdjustmentResponse;
import lithium.service.accounting.provider.internal.context.adjust.AdjustmentContext;
import lithium.service.accounting.provider.internal.services.AdjustMultiBatchService;
import lithium.service.accounting.provider.internal.services.PeriodService;
import lithium.service.accounting.provider.internal.services.TransactionServiceWrapper;
import lithium.util.ExceptionMessageUtil;
import lombok.extern.slf4j.Slf4j;

@RestController
@Slf4j
public class AccountingControllerWithExceptions implements AccountingClientWithExceptions {
	@Autowired
	TransactionServiceWrapper transactionServiceWrapper;

	@Autowired
	AdjustMultiBatchService adjustService;
	
	@Autowired
	PeriodService periodService;

	@TimeThisMethod
	@Override
	@RequestMapping("/balance/v2/getBalanceMapByAccountType")
	public Response<Map<String, Long>> getBalanceMapByAccountType(
			@RequestParam("domainName") String domainName,
			@RequestParam("accountType") String accountType,
			@RequestParam("currencyCode") String currencyCode,
			@RequestParam("ownerGuid") String ownerGuid
	) throws
			Status410AccountingAccountTypeNotFoundException,
			Status411AccountingUserNotFoundException,
			Status412AccountingDomainNotFoundException,
			Status413AccountingCurrencyNotFoundException {
		return transactionServiceWrapper.getBalanceMapByAccountType(domainName, accountType, currencyCode, ownerGuid);
	}

	@TimeThisMethod
	@Override
	@RequestMapping("/system/adjust/v1")
	public AdjustmentResponse adjust(
		@RequestBody AdjustmentRequest request
	) throws
		Status414AccountingTransactionDataValidationException,
		Status415NegativeBalanceException,
		Status500InternalServerErrorException
	{
		AdjustmentContext context = new AdjustmentContext();
		context.setRequest(request);
		context.setResponse(new AdjustmentResponse());
		
		try {
			log.info("adjustv1 pre " + context);
			adjustService.adjustMultiBatch(context);
			log.info("adjustv1 post " + context);
			return context.getResponse();
		} catch (ErrorCodeException re) {
			// No need for stack traces and error level if its an ErrorCodeException generated by
			// standard error business logic.
			log.warn("adjustv1 warn " + context +  " " + ExceptionMessageUtil.allMessages(re));
			throw re;
		} catch (Exception e) {
			log.error("adjustv1 error " + context +  " " + ExceptionMessageUtil.allMessages(e), e);
			throw e;
		}
	}
}
