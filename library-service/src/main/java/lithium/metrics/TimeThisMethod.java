package lithium.metrics;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * The {@code TimeThisMethod} annotation provides timing and metrics reporting
 * for methods utilising the currently configured spring metrics context.
 * <p>
 * This means that the method will be visible via the Spring Boot Actuator metrics
 * endpoint if configured, and will be reported to graphite / grafana in the case of the
 * default Lithium configuration.
 * <p>
 * The annotation will be picked up by the {@link LithiumMetricsTimerAspect} via the {@link EnableLithiumMetrics}
 * Spring Boot auto-configuration annotation (which is configured automatically for
 * services extending from {@link lithium.services.LithiumService}).
 * <p>
 * The {@link SW} utility class may be used inside the method to register individual steps to be tracked and
 * reported, as long as it stays within one thread since it
 * utilises {@link ThreadLocal} storage to sync up with the main stopwatch.
 * <pre>
 * {@code
 *     @TimeThisMethod
 *     private void TimeMe() throws InterruptedException {
 *         SW.start("Step 1");
 *         Thread.sleep(1000);
 *         SW.stop();
 *     }
 *
 *     private void TimeMeStep2() throws InterruptedException {
 *         SW.start("Step 2");
 *         Thread.sleep(1000);
 *         SW.stop();
 *     }
 * }
 * </pre>
 * <p>
 * It is important to note that the annotation will only work if the caller is not within the same class, and
 * the class should be obtained via a spring context (ie, it has to be a bean of some sorts). This because it depends
 * on an aspect proxy generated by Spring during bean creation. The caller will not receive the instance of the bean
 * directly, but rather a proxy created by Spring that intercepts all calls.
 * <p>
 * There are three configuration properties that have sane defaults, but could be overridden:
 * <blockquote><pre>
 * lithium:
 *   metrics:
 *     info-threshold-millis: 800
 *     warning-threshold-millis: 800
 *     error-threshold-millis: 1000
 * </pre></blockquote>
 * <p>
 * The default will skip any info logging, and log warnings for methods taking longer than 800ms to execute.
 * <p>
 * In order to test, simply set the info threshold to 0ms in your local application.yml for your service (do not commit).
 * <p>
 * @see <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html">Spring Boot Metrics</a>
 */

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TimeThisMethod {
	// There are instances where long running processes are expected, but we still would like to evaluate timings
	// to make sure it doesn't exceed our predictions. For this reason, we need to override the default thresholds
	// from configuration. If any of the values received in the annotation params is greater than zero, it will
	// override the configuration, otherwise the values in the configuration are still the default.
	long infoThresholdMillis() default 0;
	long warningThresholdMillis() default 0;
	long errorThresholdMillis() default 0;
}
